import os
import pandas as pd
from pathlib import Path
samples = config["ldna"]["samples"]

#tag BASECALLING
rule dorado:
    input:
        aref = ancient("aref.done.outfile")
    params:
        input_dir = lambda wildcards: sample_table.loc[sample_table["sample_name"] == wildcards.sample, "nanopore_rawdata_dir"].iloc[0]
    output:
        calls = expand("ldna/intermediates/{{sample}}/alignments/{{rate}}/{ref_genome}/{{sample}}.{{type}}.{{modification_string}}.bam", ref_genome = "analysis_default")
    wildcard_constraints:
        sample="[0-9A-Za-z_]+",
        type = "[0-9A-Za-z]+",
        rate = "[0-9A-Za-z]+",
        modification_string = "[0-9A-Za-z_-]+"
    container: None
    params:
        dorado = config["ldna"]["dorado"],
        reference = config["ldna"]["reference"]
    resources:
        cpus_per_task =12,
        threads = 12,
        slurm_partition="gpu-he",
        mem_mb = 128000,
        slurm_extra="--time=48:00:00 --constraint=a6000 --gres=gpu:2"
    shell:
        """
mkdir -p $(dirname {output.calls})
mod_string=$(echo {wildcards.modification_string} | tr "-" ",")

{params.dorado} \
basecaller \
{wildcards.type},$mod_string \
{params.input_dir} \
--recursive \
--verbose \
--reference {params.reference} > {output.calls}
        """

rule mod_bam_to_fastq:
    input:
        bam = expand("aref/intermediates/{{sample}}/alignments/{rate}/{{sample}}.{type}.{modification_string}.sorted.bam", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"])
    output:
        fastq = "ldna/intermediates/{sample}/fastqs/{sample}.fq"
    conda: 
        "omics"
    resources:
        cpus_per_task =12
    shell:
        """
mkdir -p $(dirname {output.fastq})
samtools fastq -T MM,ML,qs {input.bam} > {output.fastq}
        """


rule generate_meryl_index:
    benchmark:
        "ldna/benchmarks/meryl/ref.tsv"
    params:
        meryl = config["aref"]["meryl"],
        reference = config["aref"]["update_ref_with_tldr"]["tldr_input_bam_ref"]
    container: None
    output:
        k15_db = directory("ldna/meryl_k15_db"),
        repetitive_k15 = "ldna/repetitive_k15.txt"
    resources:
        cpus_per_task =24,
        runtime = 1200,
        mem_mb = 128000
    shell:
        """
mkdir -p $(dirname {output.k15_db})
{params.meryl} count k=15 threads={resources.cpus_per_task} memory=100 output {output.k15_db} {params.reference}
{params.meryl} print greater-than distinct=0.9998 {output.k15_db} > {output.repetitive_k15}
        """



rule align_to_ref_winnowmap:
    input:
        fastq = "ldna/intermediates/{sample}/fastqs/{sample}.fq",
        repetitive_k15 = "ldna/repetitive_k15.txt"
    benchmark:
        "ldna/benchmarks/winnowmap/{sample}.tsv"
    params:
        winnowmap = config["aref"]["winnowmap"],
        reference = config["aref"]["update_ref_with_tldr"]["tldr_input_bam_ref"]
    container: None
    output:
        sam = temp(expand("ldna/intermediates/{{sample}}/alignments/{rate}/{ref_genome}/{{sample}}.{type}.{modification_string}.sam",ref_genome = "winnowmap", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"]))
    resources:
        cpus_per_task =20,
        runtime = 2400,
        mem_mb = 128000
    shell:
        """
mkdir -p $(dirname {output.sam})
{params.winnowmap} -W {input.repetitive_k15} -t {resources.cpus_per_task} -y -ax map-ont {params.reference} {input.fastq} > {output.sam}
        """

rule get_winnowmap:
    input:
        expand("ldna/intermediates/{sample}/alignments/5khz/winnowmap/{sample}.hac.5mCG_5hmCG.sorted.bam.bai", sample = samples)



rule call_tldr_per_sample:
    input:
        expand("ldna/tldr/{sample_or_ref}_tldr/{sample_or_ref}.table.txt", sample = config["ldna"]["samples"], sample_or_ref = config["ldna"]["samples"])
species = config["aref"]["species"]
rule tldr_per_sample:
    input:
        bam = expand("ldna/intermediates/{{sample}}/alignments/{rate}/{ref_genome}/{{sample}}.{type}.{modification_string}.sorted.bam",ref_genome = "winnowmap", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"]),
        bai = expand("ldna/intermediates/{{sample}}/alignments/{rate}/{ref_genome}/{{sample}}.{type}.{modification_string}.sorted.bam.bai",ref_genome = "winnowmap", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"])
    benchmark:
        "ldna/benchmarks/tldr_per_sample/{sample}.tsv"
    params:
        tldr_input_bam_ref = lambda w: config["aref"]["update_ref_with_tldr"]["tldr_input_bam_ref"],
        tldr_te_ref = lambda w: config["aref"]["update_ref_with_tldr"]["tldr_te_ref"][species],
        known_nonref = lambda w: [config["aref"]["update_ref_with_tldr"]["known_nonref"]["path"] if config["aref"]["update_ref_with_tldr"]["known_nonref"]["response"] == "yes" else "not_provided"][0]
    output:
        tldr = "ldna/tldr/{sample}_tldr/{sample}.table.txt"
    resources:
        cpus_per_task = 24,
        mem_mb = 100000,
        runtime = 300
    conda:
        "tldr"
    shell:
        """
echo "params known nonref"
nonrefavailible={params.known_nonref}
echo $nonrefavailible
if [[ $nonrefavailible = "not_provided" ]]
then

tldr -b {input.bam} \
-e {params.tldr_te_ref} \
-r {params.tldr_input_bam_ref} \
-p 20 \
--minreads 1 \
--outbase {wildcards.sample} \
--detail_output \
--extend_consensus 4000 \
--trdcol

else

tldr -b {input.bam} \
-e {params.tldr_te_ref} \
-r {params.tldr_input_bam_ref} \
-p 20 \
--nonref {params.known_nonref} \
--minreads 1 \
--outbase {wildcards.sample} \
--detail_output \
--extend_consensus 4000 \
--trdcol

fi

mkdir -p $(dirname {output.tldr})
mv {wildcards.sample}.table.txt {output.tldr}
mv {wildcards.sample} $(dirname {output.tldr})/
        """






rule align_to_hg38:
    input:
        fastq = "ldna/intermediates/{sample}/fastqs/{sample}.fq",
        aref = ancient("aref.done.outfile")
    params:
        ref = "/oscar/data/jsedivy/mkelsey/ref/genomes/hg38/hg38.p13.sorted.fa"
    output:
        sam = temp(expand("ldna/intermediates/{{sample}}/alignments/{rate}/hg38/{{sample}}.{type}.{modification_string}.sam", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"]))
    resources:
        cpus_per_task =20,
        runtime = 1200,
        mem_mb = 128000
    conda: "minimap2"
    shell:
        """
mkdir -p $(dirname {output.sam})
minimap2 -a -x map-ont -t 14 -y {params.ref} {input.fastq} > {output.sam}
        """


rule telometer_prep:
    input:
        aref = ancient("aref.done.outfile")
    params:
        ref = "aref/extended/A.REF.fa",
        stong_subtelo_fa = "/oscar/data/jsedivy/mkelsey/ref/sequences/stong_subtels.fa"
    output:
        ref_telometer = "aref/extended/A.REF_telometer.fa"
    conda: "omics"
    resources:
        cpus_per_task =1,
        runtime = 30,
        mem_mb = 30000
    shell:
        """
cat {params.ref} {params.stong_subtelo_fa} > {output.ref_telometer}
samtools faidx {output.ref_telometer}
        """

rule telometer_align:
    input:
        fastq = "ldna/intermediates/{sample}/fastqs/{sample}.fq",
        ref_telometer = "aref/extended/A.REF_telometer.fa"
    output:
        sam = temp(expand("ldna/intermediates/{{sample}}/alignments/{rate}/{ref_genome}/{{sample}}.{type}.{modification_string}.sam",ref_genome = "telometer", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"]))
    resources:
        cpus_per_task =32,
        runtime = 1200,
        mem_mb = 128000
    conda: "minimap2"
    shell:
        """
mkdir -p $(dirname {output.sam})
minimap2 -a -x map-ont -t 30 -y {input.ref_telometer} {input.fastq} > {output.sam}
        """

rule telometer_split_bam:
    input:
        sortedbam = expand("ldna/intermediates/{{sample}}/alignments/{rate}/{ref_genome}/{{sample}}.{type}.{modification_string}.sorted.bam",ref_genome = "telometer", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"]),
        sortedbambai = expand("ldna/intermediates/{{sample}}/alignments/{rate}/{ref_genome}/{{sample}}.{type}.{modification_string}.sorted.bam.bai",ref_genome = "telometer", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"])
    output:
        sortedbam1 = expand("ldna/intermediates/{{sample}}/alignments/{rate}/{ref_genome}/{{sample}}.{type}.{modification_string}.1.sorted.bam",ref_genome = "telometer", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"]),
        sortedbam2 = expand("ldna/intermediates/{{sample}}/alignments/{rate}/{ref_genome}/{{sample}}.{type}.{modification_string}.2.sorted.bam",ref_genome = "telometer", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"]),
        sortedbam3 = expand("ldna/intermediates/{{sample}}/alignments/{rate}/{ref_genome}/{{sample}}.{type}.{modification_string}.3.sorted.bam",ref_genome = "telometer", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"])
    conda:
        "omics"
    shell:
        """
samtools view -b {input.sortedbam} chr1 chr2 chr3 chr4 chr5 > {output.sortedbam1}
samtools view -b {input.sortedbam} chr6 chr7 chr8 chr9 chr10 chr11 chr12  > {output.sortedbam2}
samtools view -b {input.sortedbam} chr13 chr14 chr15 chr16 chr17 chr18 chr19 chr20 chr21 chr22 chrX chrY alt1_p_0 alt2_p_0 alt3_p_0 alt4_p_0 alt5_p_0 alt6_p_0 alt7_p_0 alt8_p_0 alt9_p_0 alt10_p_0 alt11_p_0 alt12_p_0 alt13_p_0 alt14_p_0 alt15_p_0 alt16_p_0 alt17_p_0 alt18_p_0 alt19_p_0 alt20_p_0 alt21_p_0 alt22_p_0 altX_p_0 altY_p_0 alt1_q_0 alt2_q_0 alt3_q_0 alt4_q_0 alt5_q_0 alt6_q_0 alt7_q_0 alt8_q_0 alt9_q_0 alt10_q_0 alt11_q_0 alt12_q_0 alt13_q_0 alt14_q_0 alt15_q_0 alt16_q_0 alt17_q_0 alt18_q_0 alt19_q_0 alt20_q_0 alt21_q_0 alt22_q_0 altX_q_0 altY_q_0 > {output.sortedbam3}
        """
        
rule telometer:
    input:
        sortedbam = expand("ldna/intermediates/{{sample}}/alignments/{rate}/{ref_genome}/{{sample}}.{type}.{modification_string}.{{split_num}}.sorted.bam",ref_genome = "telometer", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"]),
    output:
        out = "ldna/results/tables/telometer/{sample}_{split_num}_telometer_{minimum_read_length}.tsv"
    params:
        chemistry = "r10",
    retries: 2
    resources:
        cpus_per_task =10,
        runtime = 1200,
        mem_mb = 200000
    conda: "telometer3"
    shell:
        """
mkdir -p $(dirname {output.out})
telometer -b {input.sortedbam} -o {output.out} -m {wildcards.minimum_read_length} -c {params.chemistry}
        """

rule call_telometer:
    input:
        telometer_outs = expand("ldna/results/tables/telometer/{sample}_telometer_{minimum_read_length}.tsv", sample = samples, minimum_read_length = [1000, 4000, 10000])
    output:
        "telometer.done"
    shell:
        "touch {output}"

rule samToBam:
    input:
        sam = expand("ldna/intermediates/{{sample}}/alignments/{rate}/{{ref_genome}}/{{sample}}.{type}.{modification_string}.sam", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"])
    output:
        bam = temp(expand("ldna/intermediates/{{sample}}/alignments/{rate}/{{ref_genome}}/{{sample}}.{type}.{modification_string}.bam", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"]))
    conda:
        "omics"
    resources:
        cpus_per_task =10,
        runtime = 100,
        mem_mb = 64000
    shell:
        """
samtools view -@8 -bS {input.sam} > {output.bam}
        """



rule dorado_barcode:
    input:
        dir = "ldna/rawdata/"
    output:
        calls = "ldna/intermediates/calls.bam"
    params:
        reference = config["ldna"]["reference"]
    resources:
        cpus_per_task =8,
        threads = 8,
        runtime = 5760,
        slurm_partition="gpu-he",
        mem_mb = 128000,
        slurm_extra="--time=96:00:00 --constraint=a6000 --gres=gpu:2 --mail-type=ALL --mail-user=maxfield_kelsey@brown.edu"
    shell:
        """
mkdir -p $(dirname {output})
{params.dorado} \
basecaller \
{params.basecallingModel} \
{input.dir} \
--recursive \
--verbose \
--reference {params.reference} \
--kit-name {params.sequencingKit} > {output.calls}
        """

rule dorado_demux:
    input:
        calls = "ldna/intermediates/calls.bam"
    output:
        outfile = "ldna/outfiles/demux.txt"
    resources:
        cpus_per_task =8,
        threads = 8,
        runtime = 5760,
        mem_mb = 64000
    shell:
        """
mkdir -p $(dirname {output})
/users/mkelsey/data/tools/dorado-0.4.3-linux-x64/bin/dorado demux --output-dir ./intermediates --no-classify {input.calls}
touch {output.outfile}
        """

rule extract_l1hs_aln:
    input:
        sortedbam = expand("aref/intermediates/{{sample}}/alignments/{rate}/{{sample}}.{type}.{modification_string}.sorted.bam", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"]),
        sortedbamindex = expand("aref/intermediates/{{sample}}/alignments/{rate}/{{sample}}.{type}.{modification_string}.sorted.bam", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"])
    params:
        regions = "aref/default/A.REF_annotations/A.REF_rte_beds/L1HS_ALL_ALL.bed"
    output:
        bam = "ldna/intermediates/{sample}/alignments/consensus_seq_alignments/l1hs_pulled_from_genome_aln_{sample}.bam"
    resources:
        cpus_per_task =20,
        runtime = 900,
        mem_mb = 80000
    conda:
        "omics"
    shell:
        """
mkdir -p $(dirname {output.bam})
samtools view -b -L {params.regions} {input.sortedbam} | \
samtools sort -@4 -T {wildcards.sample} -O bam -o {output.bam}
samtools index -@8 {output.bam}
samtools stats {output.bam} > {output.bam}.stats.txt 
samtools idxstat -@6 {output.bam} > {output.bam}.idxstats.txt 
        """
rule call_extractl1hsaln:
    input:
        expand("ldna/intermediates/{sample}/alignments/consensus_seq_alignments/l1hs_pulled_from_genome_aln_{sample}.bam", sample = samples)

rule extract_l1hs_aln_fastqs:
    input:
        bam = "ldna/intermediates/{sample}/alignments/consensus_seq_alignments/l1hs_pulled_from_genome_aln_{sample}.bam"
    output:
        fastq = "ldna/intermediates/{sample}/alignments/consensus_seq_alignments/l1hs_pulled_from_genome_aln_{sample}.fq"
    resources:
        cpus_per_task =10,
        threads = 10,
        runtime = 300,
        mem_mb = 32000
    conda: "omics"
    shell:
        """
mkdir -p $(dirname {output})
samtools fastq -c6 -@8 {input.bam} > {output.fastq}
        """


rule aln_to_l1hs_consensus:
    input:
        fastq = "ldna/intermediates/{sample}/alignments/consensus_seq_alignments/l1hs_pulled_from_genome_aln_{sample}.fq",
    params:
        reference = "resources/sequences/L1HS_consensus_polyA_stripped.fa"
    output:
        bam = "ldna/intermediates/{sample}/alignments/consensus_seq_alignments/l1hs_{sample}.bam"
    resources:
        cpus_per_task =20,
        runtime = 900,
        mem_mb = 80000
    conda:
        "minimap2"
    shell:
        """
mkdir -p $(dirname {output.bam})
minimap2 -a -x map-ont -2 -t 12  --sam-hit-only --secondary=no {params.reference} {input.fastq} | \
samtools sort -@4 -T {wildcards.sample} -O bam -o {output.bam}
samtools index -@8 {output.bam}
samtools stats {output.bam} > {output.bam}.stats.txt 
samtools idxstat -@6 {output.bam} > {output.bam}.idxstats.txt 
        """
rule call_alnl1hsconsensus:
    input:
        expand("ldna/intermediates/{sample}/alignments/consensus_seq_alignments/l1hs_{sample}.bam", sample = samples)

#tag QC

rule mycoplasmaCheck:
    input:
        fastq = "ldna/intermediates/{sample}/fastqs/{sample}.fq",
        aref = ancient("aref.done.outfile")
    params:
        reference = "resources/genomes/mycoplasma/mycoplasma.fa"
    output:
        bam = "ldna/qc/mycoplasma/mycoplasma{sample}.bam"
    resources:
        cpus_per_task =20,
        runtime = 900,
        mem_mb = 80000
    conda:
        "minimap2"
    shell:
        """
mkdir -p $(dirname {output.bam})
minimap2 -a -x map-ont -t 12 {params.reference} {input.fastq} | \
samtools sort -@4 -T {wildcards.sample} -O bam -o {output.bam}
samtools index -@8 {output.bam}
samtools stats {output.bam} > {output.bam}.stats.txt 
samtools idxstat -@6 {output.bam} > {output.bam}.idxstats.txt 
        """
rule call_mycoplasmaCheck:
    input:
        expand("ldna/qc/mycoplasma/mycoplasma{sample}.bam", sample = samples)
rule dorado_seqsummary:
    input:
        sortedbam = expand("ldna/intermediates/{{sample}}/alignments/{rate}/{ref_genome}/{{sample}}.{type}.{modification_string}.sorted.filtered.bam", ref_genome = "analysis_default", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"]),
        sortedbamindex = expand("ldna/intermediates/{{sample}}/alignments/{rate}/{ref_genome}/{{sample}}.{type}.{modification_string}.sorted.filtered.bam.bai", ref_genome = "analysis_default", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"]),
    params:
        dorado = config["ldna"]["dorado"]
    output:
        "ldna/qc/{sample}/{sample}.doradosummary.txt"
    conda:
        "omics"
    shell:
        """
{params.dorado} summary {input.sortedbam} > {output}
        """

rule pycoQC:
    input:
        seqsummary = "ldna/qc/{sample}/{sample}.doradosummary.txt",
        sortedbam = expand("ldna/intermediates/{{sample}}/alignments/{rate}/{ref_genome}/{{sample}}.{type}.{modification_string}.sorted.filtered.bam", ref_genome = "analysis_default", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"]),
    output:
        "ldna/qc/{sample}/{sample}pycoQC.html"
    conda:
        "pycoQC"
    shell:
        """
mkdir -p $(dirname {output})
pycoQC --summary_file {input.seqsummary} --bam_file {input.sortedbam} --html_outfile {output} --min_pass_qual 10
        """

rule multiqc:
    input:
        mycoplasma = expand("ldna/qc/mycoplasma/mycoplasma{sample}.bam", sample = samples)
    conda:
        "qc"
    output:
        report = "ldna/qc/multiqc_report.html"
    shell:
        """
multiqc --force --filename {output.report} --export ./ldna
        """

# tag ALIGNMENT_UTILITIES
rule sortBam:
    input:
        bam = "ldna/{bampath}.bam"
    output:
        sortedbam =  "ldna/{bampath}.sorted.bam",
    resources:
        cpus_per_task =10,
        mem_mb = 64000
    conda:
        "omics"
    shell:
        """
mkdir -p $(dirname {output})
samtools sort -@8 -m4g {input.bam} > {output.sortedbam}
        """


rule IndexBam:
    input:
        bam = "ldna/{bampath}.bam"
    output:
        index = "ldna/{bampath}.bam.bai"
    resources:
        cpus_per_task =10,
        mem_mb = 64000
    conda:
        "omics"
    shell:
        """
samtools index  -@6 {input.bam}
        """

# rule mergeBams:
#     input:
#         expand("ldna/intermediates/{sample}/alignments/{sample}.sorted.bam", sample = samples)
#     output:
#         mergedbam = "ldna/intermediates/merged.sorted.bam"
#     conda:
#         "minimap2"
#     resources:
#         cpus_per_task =8,
#         mem_mb = 128000,
#         slurm_extra="--time=2:00:00 --constraint=cascade"
#     log: "logs/mergeBams.log"
#     shell: "samtools merge --threads 6 {output.mergedbam} {input} 2> {log}"

# #tag ALIGNMENT_FILTERING
rule filterbam:
    input:
        bam = "ldna/{path}.sorted.bam"
    params:
        min_mapq = 10,
        min_qscore = 10
    output:
        bam = "ldna/{path}.sorted.filtered.bam"
    resources:
        cpus_per_task =6,
        mem_mb = 40000,
        runtime = 300
    conda:
        "omics"
    shell: 
        """
#keeps on only primary and supplementary alignments
samtools view -b -F 0x100 -q {params.min_mapq} -e '[qs] >= {params.min_qscore}' {input.bam} > {output.bam}
        """
#tag PHASING


rule margin_get_haplotagged_bam:
    input:
        vcf_intermediate_for_margin_haplotag = "ldna/intermediates/{sample_or_ref}/pepper/merged.vcf",
        bam = expand("ldna/intermediates/{{sample_or_ref}}/alignments/{rate}/{ref_genome}/{{sample_or_ref}}.{type}.{modification_string}.sorted.filtered.bam", ref_genome = "analysis_default", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"])
    params:
        ref = config["ldna"]["reference"]
    output:
        haplo_bam = expand("ldna/intermediates/{{sample_or_ref}}/alignments/{rate}/{ref_genome}/{{sample_or_ref}}.{type}.{modification_string}.sorted.filtered.haplotagged.bam", ref_genome = "analysis_default", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"])
    resources:
        cpus_per_task = 32,
        runtime = 1000,
        mem_mb = 128000
    container:
        "docker://kishwars/pepper_deepvariant:r0.8"
    shell:
        """
echo '{{
        "include" : "/opt/margin_dir/params/base_params.json",
        "polish": {{
                "filterAlignmentsWithMapQBelowThisThreshold": 5,
                "maxDepth": 32
        }},
        "phase" : {{
                "onlyUseSNPVCFEntries": true,
                "useVariantSelectionAdaptiveSampling": true,
                "variantSelectionAdaptiveSamplingPrimaryThreshold": 15,
                "variantSelectionAdaptiveSamplingDesiredBasepairsPerVariant": 2000,
                "minSnpVariantQuality": 10
        }}
}}' > allParams.haplotag.ont-r104q20.json

margin phase \
    {input.bam} \
    {params.ref} \
    {input.vcf_intermediate_for_margin_haplotag} \
    allParams.haplotag.ont-r104q20.json \
    --skipPhasedVCF --threads 20 --outputBase $(dirname {input.vcf_intermediate_for_margin_haplotag})/haplotagged
samtools index $(dirname {input.vcf_intermediate_for_margin_haplotag})/haplotagged.haplotagged.bam
mv $(dirname {input.vcf_intermediate_for_margin_haplotag})/haplotagged.haplotagged.bam {output.haplo_bam}
mv $(dirname {input.vcf_intermediate_for_margin_haplotag})/haplotagged.haplotagged.bam.bai {output.haplo_bam}.bai
        """

rule get_haplo_bam:
        input: expand("ldna/intermediates/{sample_or_ref}/alignments/{rate}/{ref_genome}/{sample_or_ref}.{type}.{modification_string}.sorted.filtered.haplotagged.bam", ref_genome = "analysis_default", sample_or_ref = config["ldna"]["samples"], rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"])
# rule whatshap:
#     input:
#         sortedbams = expand("ldna/intermediates/{sample}/alignments/{rate}/{ref_genome}/{sample}.{type}.{modification_string}.sorted.filtered.bam", ref_genome = "analysis_default", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"], sample = samples),
#         sortedbamsindex = expand("ldna/intermediates/{sample}/alignments/{rate}/{ref_genome}/{sample}.{type}.{modification_string}.sorted.filtered.bam.bai", ref_genome = "analysis_default", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"], sample = samples)
#     params:
#         shortreadsbam = "/oscar/data/jsedivy/mkelsey/freebayes/alignment/lf1.sorted.bam",
#         shortreadsbamindex = "/oscar/data/jsedivy/mkelsey/freebayes/alignment/lf1.sorted.bam.bai",
#         vcf = "/oscar/data/jsedivy/mkelsey/freebayes/results/variants.vcf",
#         ref = config["ldna"]["reference"]
#     output:
#         phasedvcf = "ldna/intermediates/phased.vcf"
#     resources:
#         cpus_per_task =10,
#         runtime = 1200,
#         mem_mb = 80000
#     conda:
#         "whatshap"
#     shell:	
#         """
# mkdir -p $(dirname {output})
# whatshap phase \
# --ignore-read-groups \
# -o {output.phasedvcf} \
# --reference={params.ref} \
# {params.vcf} \
# # {params.shortreadsbam} \
# # {input.sortedbams}
#         """

# rule bgzipandindexphased:
#     input:
#         phasedvcf = "ldna/intermediates/phased.vcf"
#     output:
#         phasedvcfgz = "ldna/intermediates/phased.vcf.gz"
#     conda:
#         "omics"
#     resources:
#         cpus_per_task =10
#     shell:	
#         """
# bgzip {input.phasedvcf}
# tabix {input.phasedvcf}.gz
#         """
        
# rule addphasetobam:
#     input:
#         sortedbam = expand("ldna/intermediates/{{sample}}/alignments/{rate}/{ref_genome}/{{sample}}.{type}.{modification_string}.sorted.filtered.bam", ref_genome = "analysis_default", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"]),
#         sortedbamindex = expand("ldna/intermediates/{{sample}}/alignments/{rate}/{ref_genome}/{{sample}}.{type}.{modification_string}.sorted.filtered.bam.bai", ref_genome = "analysis_default", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"]),
#         phasedvcfgz = "ldna/intermediates/phased.vcf.gz",
#         ref = config["ldna"]["reference"]
#     output:
#         haplotaggedbam = expand("ldna/intermediates/{{sample}}/alignments/{rate}/{ref_genome}/{{sample}}.{type}.{modification_string}.sorted.filtered.haplotagged.bam",ref_genome = "analysis_default", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"]),
#         haplotaggedbamindex = expand("ldna/intermediates/{{sample}}/alignments/{rate}/{ref_genome}/{{sample}}.{type}.{modification_string}.sorted.filtered.haplotagged.bam.bai",ref_genome = "analysis_default", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"])
#     resources:
#         cpus_per_task = 20
#     conda:
#         "whatshap"
#     shell:
#         """
# whatshap haplotag -o {output.haplotaggedbam} --output-threads=$(( {resources.cpus_per_task}-10 )) --ignore-read-groups --skip-missing-contigs --reference {input.ref} {input.phasedvcfgz} {input.sortedbam}
# samtools index -@ 6 {output.haplotaggedbam}
#         """

#tag METHYLATION

# rule methylartistprepdssdata:
#     input:
#         sortedbam = expand("ldna/intermediates/{{sample}}/alignments/{rate}/{ref_genome}/{{sample}}.{type}.{modification_string}.sorted.filtered.bam", ref_genome = "analysis_default", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"]),
#         sortedbamindex = expand("ldna/intermediates/{{sample}}/alignments/{rate}/{ref_genome}/{{sample}}.{type}.{modification_string}.sorted.filtered.bam.bai", ref_genome = "analysis_default", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"])
#     params:
#         ref = config["ldna"]["reference"],
#     output:
#         "ldna/intermediates/{sample}/{sample}.{context}_{mod}.dss.tsv"
#     conda: "methylartist"
#     resources:
#         cpus_per_task = 14,
#         runtime = 1000,
#         mem_mb = 128000
#     shell:
#         r"""
# mkdir -p $(dirname {output})
# /users/mkelsey/data/tools/methylartist/methylartist wgmeth -b {input.sortedbam} --dss --ref {params.ref} --fai {params.ref}.fai -o {output} -p {resources.cpus_per_task} --motif {wildcards.context} --mod {wildcards.mod} --primary_only
#         """

rule modbamtobed:
    input:
        sortedbam = expand("ldna/intermediates/{{sample}}/alignments/{rate}/{{ref_genome}}/{{sample}}.{type}.{modification_string}.sorted.filtered.bam", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"]),
        sortedbamindex = expand("ldna/intermediates/{{sample}}/alignments/{rate}/{{ref_genome}}/{{sample}}.{type}.{modification_string}.sorted.filtered.bam.bai", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"]),
    params:
        ref = lambda wildcards: "/oscar/data/jsedivy/mkelsey/ref/genomes/hg38/hg38.p13.sorted.fa" if wildcards.ref_genome == "hg38" else "aref/extended/%s.fa"%(wildcards.sample) if config["aref"]["update_ref_with_tldr"]["per_sample"] == "yes" else "aref/extended/A.REF.fa"
    resources:
        cpus_per_task = 36,
        mem_mb = 128000
    output:
        bed = "ldna/intermediates/{sample}/methylation/{ref_genome}/{sample}_CG_bedMethyl.bed",
        dssInput_m = "ldna/intermediates/{sample}/methylation/{ref_genome}/{sample}_CG_m_dss.tsv",
        dssInput_h = "ldna/intermediates/{sample}/methylation/{ref_genome}/{sample}_CG_h_dss.tsv"
    conda:
        "omics"
    shell: 
        """
echo "reference path is"
echo {params.ref}
mkdir -p $(dirname {output})
/oscar/data/jsedivy/mkelsey/tools/modkit pileup {input.sortedbam} {output.bed} \
--ref {params.ref} \
--interval-size 30000 \
--combine-strands \
--cpg \
-t {resources.cpus_per_task}

echo -e "chr\tpos\tN\tX" > {output.dssInput_m}
awk -v s=1 '$4=="m" {{OFS = "\t"; print $1, $2+s, $10, $12}}' {output.bed} >> {output.dssInput_m}
echo -e "chr\tpos\tN\tX" > {output.dssInput_h}
awk -v s=1 '$4=="h" {{OFS = "\t"; print $1, $2+s, $10, $12}}' {output.bed} >> {output.dssInput_h}
        """

rule modbamtobed_unfiltered_hardtomapregions:
    input:
        sortedbam = expand("ldna/intermediates/{{sample}}/alignments/{rate}/{{ref_genome}}/{{sample}}.{type}.{modification_string}.sorted.bam", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"]),
        sortedbamindex = expand("ldna/intermediates/{{sample}}/alignments/{rate}/{{ref_genome}}/{{sample}}.{type}.{modification_string}.sorted.bam.bai", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"]),
    params:
        ref = lambda wildcards: "/oscar/data/jsedivy/mkelsey/ref/genomes/hg38/hg38.p13.sorted.fa" if wildcards.ref_genome == "hg38" else "aref/extended/%s.fa"%(wildcards.sample) if config["aref"]["update_ref_with_tldr"]["per_sample"] == "yes" else "aref/extended/A.REF.fa",
        regions = "/users/mkelsey/data/Nanopore/alz/RTE/hgUnique.hg38.bed6"
    resources:
        cpus_per_task = 36,
        mem_mb = 128000
    output:
        bed = "ldna/intermediates/{sample}/methylation/{ref_genome}/{sample}_CG_bedMethyl_unfiltered_hardtomapregions.bed",
        dssInput_m = "ldna/intermediates/{sample}/methylation/{ref_genome}/{sample}_CG_m_dss_unfiltered_hardtomapregions.tsv",
        dssInput_h = "ldna/intermediates/{sample}/methylation/{ref_genome}/{sample}_CG_h_dss_unfiltered_hardtomapregions.tsv"
    conda:
        "omics"
    shell: 
        """
echo "reference path is"
echo {params.ref}
mkdir -p $(dirname {output})
/oscar/data/jsedivy/mkelsey/tools/modkit pileup {input.sortedbam} {output.bed} \
--ref {params.ref} \
--interval-size 30000 \
--combine-strands \
--cpg \
--include-bed {params.regions} \
-t {resources.cpus_per_task}

echo -e "chr\tpos\tN\tX" > {output.dssInput_m}
awk -v s=1 '$4=="m" {{OFS = "\t"; print $1, $2+s, $10, $12}}' {output.bed} >> {output.dssInput_m}
echo -e "chr\tpos\tN\tX" > {output.dssInput_h}
awk -v s=1 '$4=="h" {{OFS = "\t"; print $1, $2+s, $10, $12}}' {output.bed} >> {output.dssInput_h}
        """


rule bedmethylanalysis_process_unfiltered_hardtomapregions:
    input:
        # dmrs = "ldna/results/{mod_code}/tables/dmrs.tsv",
        # dmls = "ldna/results/{mod_code}/tables/dmls.tsv",
        bedmethylpaths = expand("ldna/intermediates/{sample}/methylation/{ref_genome}/{sample}_CG_bedMethyl_unfiltered_hardtomapregions.bed", sample = samples, ref_genome = "analysis_default"),
    params:
        mod_code = lambda wildcards: wildcards.mod_code
    output:
        grsdf = "ldna/Rintermediates/{mod_code}/grsdf_unfiltered_hardtomapregions.tsv"
    resources:
        cpus_per_task =10,
        mem_mb = 200000,
        runtime = 400
    conda:
        "ds"
    script:
        "scripts/bedmethylanalysis_process_unfiltered_hardtomapregions.R"

# rule methbigwig:
#     input:
#         bed = "ldna/intermediates/{sample}/methylation/{ref_genome}/{sample}_CG_bedMethyl.bed"
#     output:
#         meth_bed = "ldna/intermediates/{sample}/methylation/{ref_genome}/{sample}_CG_m.bed",
#         hmeth_bed = "ldna/intermediates/{sample}/methylation/{ref_genome}/{sample}_CG_h.bed",
#         meth_bw = "ldna/intermediates/{sample}/methylation/{ref_genome}/{sample}_CG_m_50bp.bw",
#         hmeth_bw = "ldna/intermediates/{sample}/methylation/{ref_genome}/{sample}_CG_h_50bp.bw",
#     conda:
#         "omics"
#     shell:
#         """
# cat {input.bed} | awk 'BEGIN{{OFS="\t"}} $4=="m" && NR>1{{print $1,$2,$3,$4,$11}}' > {output.meth_bedgraph}
# cat {input.bed} | awk 'BEGIN{{OFS="\t"}} $4=="h" && NR>1{{print $1,$2,$3,$4,$11}}' > {output.hmeth_bedgraph}

# bedtools makewindows 
# bedmap --echo --mean --range 100 windows.bed map.bed


# bigwigAverage -b sample1.bw sample2.bw -o outfile.bw
#         """

rule modbamtobed_region:
    input:
        sortedbam = expand("ldna/intermediates/{{sample}}/alignments/{rate}/{ref_genome}/{{sample}}.{type}.{modification_string}.sorted.filtered.bam", ref_genome = "analysis_default", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"]),
        sortedbamindex = expand("ldna/intermediates/{{sample}}/alignments/{rate}/{ref_genome}/{{sample}}.{type}.{modification_string}.sorted.filtered.bam.bai", ref_genome = "analysis_default", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"])
    params:
        ref = config["ldna"]["reference"],
        reference_annotation_dir = config["ldna"]["reference_annotation_dir"]
    resources:
        cpus_per_task = 36,
        mem_mb = 128000
    output:
        bed = "ldna/intermediates/{sample}/methylation/analysis_default/{sample}_{element}_nocontext_bedMethyl.bed",
        dssInput_m = "ldna/intermediates/{sample}/methylation/analysis_default/{sample}_{element}_nocontext.m_dss.tsv",
        dssInput_h = "ldna/intermediates/{sample}/methylation/analysis_default/{sample}_{element}_nocontext.h_dss.tsv",
        dssInput_a = "ldna/intermediates/{sample}/methylation/analysis_default/{sample}_{element}_nocontext.a_dss.tsv"
    conda:
        "omics"
    shell: 
        """
mkdir -p $(dirname {output})
bedpath=$(echo {params.reference_annotation_dir}/annotations/rte_beds/{wildcards.element}.bed)
/oscar/data/jsedivy/mkelsey/tools/modkit pileup {input.sortedbam} {output.bed} \
--ref {params.ref} \
--interval-size 30000 \
--include-bed $bedpath \
--force-allow-implicit \
-t {resources.cpus_per_task}

echo -e "chr\tpos\tN\tX" > {output.dssInput_m}
echo -e "chr\tpos\tN\tX" > {output.dssInput_h}
echo -e "chr\tpos\tN\tX" > {output.dssInput_a}

awk -v s=1 '$4=="m" {{OFS = "\t"; print $1, $2+s, $10, $12}}' {output.bed} >> {output.dssInput_m}
awk -v s=1 '$4=="h" {{OFS = "\t"; print $1, $2+s, $10, $12}}' {output.bed} >> {output.dssInput_h}
awk -v s=1 '$4=="a" {{OFS = "\t"; print $1, $2+s, $10, $12}}' {output.bed} >> {output.dssInput_a}
        """

# rule modbamtobedTLDRinsertions:
#     input:
#         tldr = "aref/{sample}_tldr/{sample}.table.txt"
#     params:
#         ref = config["aref"]["update_ref_with_tldr"]["tldr_te_ref"],
#         indir = "ldna/tldr/{sample}"
#     resources:
#         cpus_per_task = 4,
#         mem_mb = 30000
#     output:
#         outfile = "outfiles/{sample}.bedmethyltldr.txt"
#     conda:
#         "omics"
#     shell: 
#         """
# bash scripts/bedmethtldr.sh {params.indir}
# touch {output.outfile}
#         """

rule dss:
    input:
        data = expand("ldna/intermediates/{sample}/methylation/{ref_genome}/{sample}_CG_{{mod_code}}_dss.tsv", sample = samples, ref_genome = "analysis_default"),
    params:
        chromosome = lambda w: w.chr
    output:
        dmls_unfiltered = "ldna/results/{mod_code}/tables/dmls.{chr}.unfiltered.tsv",
        dmrs_unfiltered = "ldna/results/{mod_code}/tables/dmrs.{chr}.unfiltered.tsv",
        dmls = "ldna/results/{mod_code}/tables/dmls.{chr}.tsv",
        dmrs = "ldna/results/{mod_code}/tables/dmrs.{chr}.tsv"
    conda:
        "dss2"
    resources:
        cpus_per_task = 10,
        mem_mb = lambda w, attempt: 120000 * attempt
    retries: 3
    script:
        "scripts/dss.R"


rule merge_dss:
    input:
        dmrs = expand("ldna/results/{{mod_code}}/tables/dmrs.{chr}.tsv", chr = [chrid for chrid in ["chr%s"%e for e in list(range(1, 23)) + ["X", "Y"]] if chrid not in config["ldna"]["SEX_CHROMOSOMES_NOT_INCLUDED_IN_ANALYSIS"]]),
        dmls = expand("ldna/results/{{mod_code}}/tables/dmls.{chr}.tsv", chr = [chrid for chrid in ["chr%s"%e for e in list(range(1, 23)) + ["X", "Y"]] if chrid not in config["ldna"]["SEX_CHROMOSOMES_NOT_INCLUDED_IN_ANALYSIS"]])
    output:
        dmrs = "ldna/results/{mod_code}/tables/dmrs.tsv",
        dmls = "ldna/results/{mod_code}/tables/dmls.tsv",
        dmrs_bed = "ldna/results/{mod_code}/tables/dmrs.bed",
        dmrs_hypo_bed = "ldna/results/{mod_code}/tables/dmrs_hypo.bed",
        dmrs_hyper_bed = "ldna/results/{mod_code}/tables/dmrs_hyper.bed"
    priority: 100
    conda:
        "repeatanalysis"
    script:
        "scripts/merge_dss.R"


rule extractmods:
    input:
        sortedbam = expand("ldna/intermediates/{{sample}}/alignments/{rate}/{ref_genome}/{{sample}}.{type}.{modification_string}.sorted.filtered.bam", ref_genome = "analysis_default", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"]),
        sortedbamindex = expand("ldna/intermediates/{{sample}}/alignments/{rate}/{ref_genome}/{{sample}}.{type}.{modification_string}.sorted.filtered.bam.bai", ref_genome = "analysis_default", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"])
    output:
        read_mods = 'ldna/intermediates/{sample}/methylation/analysis_default/{sample}_readmods_NoContext_{region}.tsv'
    params:
        ref = config["ldna"]["reference"],
        ref_annotation_dir = config["ldna"]["reference_annotation_dir"],
        region = lambda wildcards: "aref/extended/%s_annotations/%s_rte_beds/outfile.txt"%(wildcards.sample, wildcards.sample) if config["aref"]["update_ref_with_tldr"]["per_sample"] == "yes" else "aref/extended/A.REF_annotations/A.REF_rte_beds/outfile.txt"
    resources:
        cpus_per_task = 8,
        mem_mb = 80000
    conda:
        "omics"
    shell: 
        """
mkdir -p $(dirname {output})
/oscar/data/jsedivy/mkelsey/tools/modkit extract \
--mapped \
--no-filtering \
--include-bed $(dirname {params.region})/{wildcards.region}.bed \
--ref {params.ref} \
--threads {resources.cpus_per_task} \
{input.sortedbam} \
{output.read_mods}
        """

rule extractmods_cg_context:
    input:
        sortedbam = expand("ldna/intermediates/{{sample}}/alignments/{rate}/{ref_genome}/{{sample}}.{type}.{modification_string}.sorted.filtered.bam", ref_genome = "analysis_default", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"]),
        sortedbamindex = expand("ldna/intermediates/{{sample}}/alignments/{rate}/{ref_genome}/{{sample}}.{type}.{modification_string}.sorted.filtered.bam.bai", ref_genome = "analysis_default", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"]),
    output:
        read_mods = 'ldna/intermediates/{sample}/methylation/analysis_default/{sample}_readmods_CpG_{region}.tsv'
    params:
        ref = config["ldna"]["reference"],
        ref_annotation_dir = config["ldna"]["reference_annotation_dir"],
        region = lambda wildcards: "aref/extended/%s_annotations/%s_rte_beds/outfile.txt"%(wildcards.sample, wildcards.sample) if config["aref"]["update_ref_with_tldr"]["per_sample"] == "yes" else "aref/extended/A.REF_annotations/A.REF_rte_beds/outfile.txt"
    resources:
        cpus_per_task = 8,
        mem_mb = 80000
    conda:
        "omics"
    shell: 
        """
mkdir -p $(dirname {output})

/oscar/data/jsedivy/mkelsey/tools/modkit extract \
--cpg \
--mapped \
--no-filtering \
--include-bed $(dirname {params.region})/{wildcards.region}.bed \
--ref {params.ref} \
--threads {resources.cpus_per_task} \
{input.sortedbam} \
{output.read_mods}
        """

rule genomewide_meth:
    input:
        dss = expand("ldna/intermediates/{sample}/methylation/{ref_genome}/{sample}_CG_{{mod_code}}_dss.tsv", sample = samples, ref_genome = "analysis_default")
    output:
        plots = "ldna/results/{mod_code}/plots/genomewide/genomewide_meth_plots.rds"
    resources:
        cpus_per_task =10,
        mem_mb = 200000,
        runtime = 400
    conda:
        "ds"
    script:
        "scripts/bedmethylanalysis.R"


rule l1hs_alignment:
    input:
        r_annotation_fragmentsjoined = "aref/extended/A.REF_annotations/A.REF_repeatmasker.gtf.rformatted.fragmentsjoined.csv",
        r_repeatmasker_annotation = "aref/extended/A.REF_annotations/A.REF_repeatmasker_annotation.csv",
        ref = "aref/extended/A.REF.fa"
    output:
        consensus_map = "ldna/results/m/plots/l1_alignment_meth/L1HS_fl_mapping_to_consensus_table.csv"
    resources:
        cpus_per_task =10,
        mem_mb = 200000,
        runtime = 400
    conda:
        "evo2"
    script:
        "scripts/l1hs_alignment.R"

if config["ldna"]["single_condition"] == "yes":
    ruleorder: bedmethylanalysis_process_single_condition > bedmethylanalysis_process
else:
    ruleorder:  bedmethylanalysis_process > bedmethylanalysis_process_single_condition
rule bedmethylanalysis_process:
    input:
        dmrs = "ldna/results/{mod_code}/tables/dmrs.tsv",
        dmls = "ldna/results/{mod_code}/tables/dmls.tsv",
        bedmethylpaths = expand("ldna/intermediates/{sample}/methylation/{ref_genome}/{sample}_CG_bedMethyl.bed", sample = samples, ref_genome = "analysis_default"),
        read_mods = expand('ldna/intermediates/{sample}/methylation/{ref_genome}/{sample}_readmods_{context}_{region}.tsv', sample = samples, ref_genome = "analysis_default", region = config["ldna"]["rte_subfamily_read_level_analysis"], context = ["CpG", "NoContext"]),
        consensus_map = "ldna/results/m/plots/l1_alignment_meth/L1HS_fl_mapping_to_consensus_table.csv"
    params:
        mod_code = lambda wildcards: wildcards.mod_code
    output:
        grsdf = "ldna/Rintermediates/{mod_code}/grsdf.tsv"
    resources:
        cpus_per_task =10,
        mem_mb = 200000,
        runtime = 400
    conda:
        "ds"
    script:
        "scripts/bedmethylanalysis_process.R"

rule bedmethylanalysis_process_single_condition:
    input:
        bedmethylpaths = expand("ldna/intermediates/{sample}/methylation/{ref_genome}/{sample}_CG_bedMethyl.bed", sample = samples, ref_genome = "analysis_default"),
        read_mods = expand('ldna/intermediates/{sample}/methylation/{ref_genome}/{sample}_readmods_{context}_{region}.tsv', sample = samples, ref_genome = "analysis_default", region = config["ldna"]["rte_subfamily_read_level_analysis"], context = ["CpG", "NoContext"])
    params:
        mod_code = lambda wildcards: wildcards.mod_code
    output:
        grsdf = "ldna/Rintermediates/{mod_code}/grsdf.tsv"
    resources:
        cpus_per_task =10,
        mem_mb = 200000,
        runtime = 400
    conda:
        "ds"
    script:
        "scripts/bedmethylanalysis_process.R"


rule bedmethylanalysis_plot:
    input:
        grsdf = "ldna/Rintermediates/{mod_code}/grsdf.tsv"
        # read_mods = expand('ldna/intermediates/{sample}/methylation/{ref_genome}/{sample}_readmods_{context}_{region}.tsv', sample = samples, region = config["ldna"]["rte_subfamily_read_level_analysis"], context = ["CpG", "NoContext"])
    params:
        mod_code = lambda wildcards: wildcards.mod_code,
        dmrs = lambda wildcards: "ldna/results/%s/tables/dmrs.tsv"%wildcards.mod_code,
        dmls = lambda wildcards: "ldna/results/%s/tables/dmls.tsv"%wildcards.mod_code
    output:
        plots = "ldna/results/{mod_code}/plots/bedmethylanalysis.rds",
        promoters_bed = "ldna/Rintermediates/{mod_code}/promoters.bed",
        dmrpromoterhyper_bed = "ldna/Rintermediates/{mod_code}/promoters_dmhyperregions.bed",
        dmrpromoterhypo_bed = "ldna/Rintermediates/{mod_code}/promoters_dmhyporegions.bed"
    resources:
        cpus_per_task =10,
        mem_mb = 200000,
        runtime = 400
    conda:
        "ds"
    script:
        "scripts/bedmethylanalysis_plot.R"


rule insertion_analysis:
    params:
        filtered_tldr = lambda wildcards: expand("aref/extended/{sample}.table.kept_in_updated_ref.txt", sample = samples) if config["aref"]["update_ref_with_tldr"]["per_sample"] == "yes" else "aref/A.REF_tldr/A.REF.table.kept_in_updated_ref.txt",
        rmann_nonref = lambda wildcards: expand("aref/extended/{sample}_annotations/{sample}_rmann_nonref.csv", sample = samples) if config["aref"]["update_ref_with_tldr"]["per_sample"] == "yes" else "aref/extended/A.REF_annotations/A.REF_repeatmasker_annotation.csv"
    output:
        plots = "ldna/results/insertion_analysis/insertion_analysis.rds",
    conda:
        "evo2"
    script:
        "scripts/insertion_analysis.R"

# rule modbamtobedTLDRinsertionsCombinedCall:
#     input:
#         tldr = "tldr/SEN1.filtered_PRO1.filtered.table.txt"
#     params:
#         ref = config["ldna"]["hs1sorted"],
#         indir = "tldr/SEN1.filtered_PRO1.filtered"
#     resources:
#         cpus_per_task = 4,
#         mem_mb = 30000
#     output:
#         outfile = "outfiles/bedmethyltldrCombinedCall.txt"
#     conda:
#         "omics"
#     shell: 
#         """
# bash scripts/bedmethtldr.sh {params.indir}
# touch {output.outfile}
#         """


rule callmodbamtools:
    input:
        expand("ldna/results/{sample}/outfile.txt", sample = samples)

rule modbamtools:
    input:
        sortedbam = "ldna/intermediates/{sample}/alignments/{sample}.sorted.bam",
    params:
        refseq = config["ldna"]["refseq"],
        outdir = "results/{sample}"
    output:
        outfile = "ldna/results/{sample}/outfile.txt"        
    conda:
        "modbam"
    shell:
        """
mkdir -p $(dirname {output})

modbamtools plot -r chr20:58815000-58895000 \
    --gtf {params.refseq} \
    --out {params.outdir} \
    --prefix {wildcards.sample} \
    --samples {wildcards.sample} \
    --track-titles Genes \
    {input.sortedbam}
touch {output.outfile}
        """



rule callmodbamtobedandextractmods:
    input:
        [expand("ldna/intermediates/{sample}/methylation/{ref_genome}/{sample}_{context}_bedMethyl.bed", sample = samples, ref_genome = "analysis_default", context = ["CG", "C", "A"]),
        expand("ldna/intermediates/{sample}/methylation/{ref_genome}/{sample}_mods.tsv", sample = samples, ref_genome = "analysis_default")]


#tag Methylation plots

rule init_wgbstools_default_ref:
    input:
        aref = ancient("aref.done.outfile")
    params:
        ref = "aref/extended/A.REF.fa"
    output:
        outfile = "aref/extended/A.REF.analysis_default.wgbs.init.out"
    resources:
        runtime = 1000,
        mem_mb = 128000,
        cpus_per_task = 10
    conda: "omics"
    shell:
        """
mkdir -p $(dirname {output})
/users/mkelsey/data/tools/wgbs_tools/wgbstools init_genome --fasta_path {params.ref} analysis_default
touch {output.outfile}
        """

rule init_wgbstools_hg38:
    input:
        aref = ancient("aref.done.outfile")
    params:
        ref = "/oscar/data/jsedivy/mkelsey/ref/genomes/hg38/hg38.p13.sorted.fa"
    output:
        outfile = "aref/extended/A.REF.hg38.wgbs.init.out"
    resources:
        runtime = 1000,
        mem_mb = 128000,
        cpus_per_task = 10
    conda: "omics"
    shell:
        """
mkdir -p $(dirname {output})
/users/mkelsey/data/tools/wgbs_tools/wgbstools init_genome --fasta_path {params.ref} hg38
touch {output.outfile}
        """
rule wgbs_bam2pat:
    input:
        outfile = "aref/extended/A.REF.{ref_genome}.wgbs.init.out",
        bam = expand("ldna/intermediates/{{sample}}/alignments/{rate}/{{ref_genome}}/{{sample}}.{type}.{modification_string}.sorted.filtered.bam", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"]),
    output:
        pat = expand("ldna/results/{{mod_code}}/wgbs/{{ref_genome}}/{{sample}}.{type}.{modification_string}.sorted.filtered.pat.gz", type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"]),
    resources:
        runtime = 1000,
        mem_mb = 128000,
        cpus_per_task = 26
    conda: "omics"
    shell:
        """
mkdir -p $(dirname {output})
/users/mkelsey/data/tools/wgbs_tools/wgbstools bam2pat --genome {wildcards.ref_genome} -@ 26 --nanopore {input.bam} --out_dir $(dirname {output.pat})
        """

rule get_hg38_pat:
    input:
        pat = expand("ldna/results/m/wgbs/hg38/{sample}.{type}.{modification_string}.sorted.filtered.pat.gz", type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"], sample= samples),

rule uxm_deconv:
    input:
        pat = expand("ldna/results/m/wgbs/hg38/{sample}.{type}.{modification_string}.sorted.filtered.pat.gz", type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"], sample = samples)
    params:
        atlas = "/users/mkelsey/data/Nanopore/alz/Atlas.U25.l4.hg38.tsv"
    output:
        csv = "ldna/results/m/wgbs/hg38/tables/deconv.csv"
    conda: "omics"
    shell:
        """
mkdir -p $(dirname {output.csv})
uxm deconv --atlas {params.atlas} --output {output.csv} --verbose {input.pat}
outputcsv={output.csv}
uxm deconv --include Neuron Oligodend --atlas {params.atlas} --output ${{outputcsv%.*}}.brainsubset.csv --verbose {input.pat}

        """



rule get_merged_pat:
    input:
        pat = expand("ldna/results/{{mod_code}}/wgbs/analysis_default/{sample}.{type}.{modification_string}.sorted.filtered.pat.gz", type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"], sample = samples)
    params:
        inputdir = lambda wildcards: "ldna/results/%s/wgbs/analysis_default"%wildcards.mod_code,
        level1 = config["ldna"]["levels"][0],
        level2 = lambda wildcards: config["ldna"]["levels"][1] if len(config["ldna"]["levels"]) > 1 else None,  # Second level if exists    
    conda:
        "omics"
    output:
        outfile = "ldna/results/{mod_code}/wgbs/analysis_default/merged/merged.outfile"
    shell:
        """
mkdir -p $(dirname {output.outfile})
/users/mkelsey/data/tools/wgbs_tools/wgbstools merge -p $(dirname {output.outfile})/{params.level1} --genome hs1 {params.inputdir}/{params.level1}*.pat.gz

if [ -n "{params.level2}" ]; then
    /users/mkelsey/data/tools/wgbs_tools/wgbstools merge -p $(dirname {output.outfile})/{params.level2} --genome hs1 {params.inputdir}/{params.level2}*.pat.gz
fi
touch {output.outfile}
        """

rule pat_fig:
    input:
        outfile = "ldna/results/{mod_code}/wgbs/analysis_default/merged/merged.outfile"
        # pat = expand("ldna/results/wgbs/{sample}.{type}.{modification_string}.sorted.filtered.pat.gz", type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"], sample = samples)
    params:
        # methylartist_loci_of_interest = config["ldna"]["methylartist_loci_of_interest"],
        loci_of_interest = lambda wildcards: ["aref/A.REF_annotations/A.REF_rte_beds/L1HS_intactness_req_ALL.bed", "ldna/Rintermediates/%s/audrey_element.bed"%wildcards.mod_code, "ldna/Rintermediates/%s/audrey_element_promoter.bed"%wildcards.mod_code, "ldna/Rintermediates/%s/dm_FL_L1HS_promoters.bed"%wildcards.mod_code, "ldna/Rintermediates/%s/dm_Intact_L1HS_promoters.bed"%wildcards.mod_code]
    output:
        outfile = "ldna/results/{mod_code}/wgbs/plots/pat_fig.outfile"
        # pat_fig = "ldna/results/wgbs/plots/{region}.pat.pdf"
    resources:
        runtime = 100,
        mem_mb = 10000,
        cpus_per_task = 4
    conda: "omics"
    shell:
        """
for file in {params.loci_of_interest}
do
    basename=$(basename $file)
    basename_no_ext=${{basename%%.*}}
    coords=$(awk '{{print $1":"$2"-"$3}}' $file)
    mapfile -t coords_array <<< "$coords"
        for coord in "${{coords_array[@]}}"
        do
        coordfnsafe=$(echo $coord | sed 's/:/-/')
        mkdir -p $(dirname {output.outfile})/${{basename_no_ext}}
        /users/mkelsey/data/tools/wgbs_tools/wgbstools pat_fig --nanopore --circle_size 1.2 --line_width 0.25  --col_wrap 1 --font_size 3 --meth_color "beige" --unmeth_color "black"  -o $(dirname {output.outfile})/${{basename_no_ext}}/${{coordfnsafe}}.pdf -r $coord --strict --genome hs1 $(dirname {input.outfile})/*.pat.gz
        /users/mkelsey/data/tools/wgbs_tools/wgbstools pat_fig --nanopore --circle_size 1.2 --line_width 0.25  --col_wrap 4 --font_size 3 --meth_color "beige" --unmeth_color "black"  -o $(dirname {output.outfile})/${{basename_no_ext}}/${{coordfnsafe}}_2col.pdf -r $coord --strict --genome hs1 $(dirname {input.outfile})/*.pat.gz
        /users/mkelsey/data/tools/wgbs_tools/wgbstools pat_fig --nanopore --circle_size 1.2 --line_width 0.25 --col_wrap 6 --font_size 3 --meth_color "beige" --unmeth_color "black"  -o $(dirname {output.outfile})/${{basename_no_ext}}/${{coordfnsafe}}_all_samples.pdf -r $coord --strict --name_table /users/mkelsey/data/Nanopore/alz/RTE/conf/WGBS_rename.csv --genome hs1 $(dirname $(dirname {input.outfile}))/*.pat.gz
    done
done
touch {output.outfile}
        """

rule pat_fig_rtes:
    input:
        outfile = "ldna/results/{mod_code}/wgbs/analysis_default/merged/merged.outfile"
        # pat = expand("ldna/results/wgbs/{sample}.{type}.{modification_string}.sorted.filtered.pat.gz", type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"], sample = samples)
    params:
        fl_rte = lambda wildcards: "/users/mkelsey/data/Nanopore/alz/RTE/ldna/Rintermediates/%s/flRTEpromoter.tsv"%wildcards.mod_code
    output:
        outfile = "ldna/results/{mod_code}/wgbs/plots/l1hs/l1hs_fl.outfile"
        # pat_fig = "ldna/results/wgbs/plots/{region}.pat.pdf"
    resources:
        runtime = 100,
        mem_mb = 10000,
        cpus_per_task = 4
    conda: "omics"
    shell:
        """
coords=$(awk '{{print $1":"$2"-"$3}}' <<< $(grep "L1HS" {params.fl_rte}))
rte_name=$(awk '{{print $6}}' <<< $(grep "L1HS" {params.fl_rte}))
mapfile -t coords_array <<< "$coords"
mapfile -t rte_name_array <<< "$rte_name"
for (( i=0; i<${{#coords_array[@]}}; i++ ))
do
coord=${{coords_array[$i]}}
rte_name=${{rte_name_array[$i]}}
coordfnsafe=$(echo $coord | sed 's/:/-/')
/users/mkelsey/data/tools/wgbs_tools/wgbstools pat_fig --nanopore --shuffle --line_width 0.5 --col_wrap 1 --font_size 3 --meth_color "beige" --unmeth_color "black"  -o $(dirname {output.outfile})/${{coordfnsafe}}_top20.pdf -r $coord --title $rte_name --strict --genome hs1 --top 20 $(dirname {input.outfile})/*.pat.gz
/users/mkelsey/data/tools/wgbs_tools/wgbstools pat_fig --nanopore --shuffle --line_width 0.5 --col_wrap 1 --font_size 3 --meth_color "beige" --unmeth_color "black"  -o $(dirname {output.outfile})/${{coordfnsafe}}.pdf -r $coord --title $rte_name --strict --genome hs1 $(dirname {input.outfile})/*.pat.gz
/users/mkelsey/data/tools/wgbs_tools/wgbstools pat_fig --nanopore --shuffle --line_width 0.5 --col_wrap 1 --font_size 3 --meth_color "beige" --unmeth_color "black"  -o $(dirname {output.outfile})/${{coordfnsafe}}_top50.pdf -r $coord --title $rte_name --strict --genome hs1 --top 50 $(dirname {input.outfile})/*.pat.gz
/users/mkelsey/data/tools/wgbs_tools/wgbstools pat_fig --nanopore --shuffle --line_width 0.5 --col_wrap 1 --font_size 3 --meth_color "beige" --unmeth_color "black"  -o $(dirname {output.outfile})/${{coordfnsafe}}_top100.pdf -r $coord --title $rte_name --strict --genome hs1 --top 100 $(dirname {input.outfile})/*.pat.gz
done
touch {output.outfile}
        """

rule pat_fig_rtes_by_sample:
    input:
        outfile = "ldna/results/{mod_code}/wgbs/analysis_default/merged/merged.outfile"
        # pat = expand("ldna/results/wgbs/{sample}.{type}.{modification_string}.sorted.filtered.pat.gz", type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"], sample = samples)
    params:
        fl_rte = lambda wildcards: "/users/mkelsey/data/Nanopore/alz/RTE/ldna/Rintermediates/%s/flRTEpromoter.tsv"%wildcards.mod_code
    output:
        outfile = "ldna/results/{mod_code}/wgbs/plots/l1hs/by_sample/l1hs_fl_by_sample.outfile"
        # pat_fig = "ldna/results/wgbs/plots/{region}.pat.pdf"
    resources:
        runtime = 100,
        mem_mb = 10000,
        cpus_per_task = 4
    conda: "omics"
    shell:
        """
coords_array=()
rte_name_array=()

while read -r line; do
    coords_array+=("$(awk '{{print $1":"$2"-"$3}}' <<< "$line")")
    rte_name_array+=("$(awk '{{print $6}}' <<< "$line")")
done < <(grep "L1HS" {params.fl_rte})

echo "read lines"

for (( i=0; i<${{#coords_array[@]}}; i++ ))
do
coord=${{coords_array[$i]}}
rte_name=${{rte_name_array[$i]}}
coordfnsafe=$(echo $coord | sed 's/:/-/')
/users/mkelsey/data/tools/wgbs_tools/wgbstools pat_fig --nanopore --shuffle --line_width 0.5 --col_wrap 1 --font_size 3 --meth_color "beige" --unmeth_color "black"  -o $(dirname {output.outfile})/${{rte_name}}_1col.pdf -r $coord --title $rte_name --strict --genome hs1 $(dirname $(dirname {input.outfile}))/*.pat.gz
/users/mkelsey/data/tools/wgbs_tools/wgbstools pat_fig --nanopore --shuffle --line_width 0.5 --col_wrap 6 --font_size 3 --meth_color "beige" --unmeth_color "black"  -o $(dirname {output.outfile})/${{rte_name}}_6col.pdf -r $coord --title $rte_name --strict --genome hs1 $(dirname $(dirname {input.outfile}))/*.pat.gz

done
touch {output.outfile}
        """

rule methylartistlocusplot_loci_of_interest:
    input:
        sortedbam = expand("ldna/intermediates/{sample}/alignments/{rate}/{ref_genome}/{sample}.{type}.{modification_string}.sorted.filtered.bam", ref_genome = "analysis_default", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"], sample = samples),
        sortedbai = expand("ldna/intermediates/{sample}/alignments/{rate}/{ref_genome}/{sample}.{type}.{modification_string}.sorted.filtered.bam.bai", ref_genome = "analysis_default",rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"], sample = samples),
        dmrs = "ldna/results/{mod_code}/tables/dmrs.tsv",
        repeatmaskerbgz = "/users/mkelsey/data/Nanopore/alz/RTE/aref/extended/A.REF_annotations/A.REF_repeatmasker.complete.gtf.gz",
    resources:
        runtime = 180,
        mem_mb = 5000
    params:
        ref = config["ldna"]["reference"],
        refseqbgz = config["ldna"]["refseqbgz"],
        methylartist_bam_config = config["ldna"]["methylartist_bam_config"],
        methylartist_loci_of_interest = config["ldna"]["methylartist_loci_of_interest"],
        module_prefix = config["ldna"]["prefix"],
        outputprefix = lambda wildcards: "results/%s/plots/methylartist/locus/loci_of_interest_"%wildcards.mod_code,
    output:
        "ldna/results/{mod_code}/plots/methylartist/locus/methylartistlocusplot_loci_of_interest.outfile"

    conda:
        "methylartist2"
    shell:
        r"""
mkdir -p $(dirname {output})
outputprefix=$(dirname {output})/methylartistlocusplot_loci_of_interest_
bams=$(echo {input.sortedbam})
commabams=$(echo $bams | tr ' ' ',')
coords=$(awk '{{print $1":"$2"-"$3}}' {params.methylartist_loci_of_interest})
mapfile -t coords_array <<< "$coords"
for coord in "${{coords_array[@]}}"
do
coordfnsafe=$(echo $coord | sed 's/:/-/')
echo $coordfnsafe
if /users/mkelsey/data/tools/methylartist/methylartist locus \
--bams {params.methylartist_bam_config} \
-o ${{outputprefix}}${{coordfnsafe}}.png \
-i $coord \
--ref {params.ref} \
--motif CG \
-m m \
--highlight_bed {input.dmrs} \
-p 1,6,1,0,4 \
--labelgenes \
--gtf {input.repeatmaskerbgz}; \
then
echo "worked"
else
echo "failed"
fi
# if /users/mkelsey/data/tools/methylartist/methylartist locus --bams {params.methylartist_bam_config} -o ${{outputprefix}}${{coordfnsafe}}.png -i $coord --ref {params.ref} --motif CG -m m --highlight_bed {input.dmrs} -p 1,6,1,0,4 --labelgenes --svg; then
# echo "worked"
# else
# echo "failed"
# fi
done
touch {output}       
        """


rule methylartistlocusplot_region_of_interest:
    input:
        sortedbam = expand("ldna/intermediates/{sample}/alignments/{rate}/{ref_genome}/{sample}.{type}.{modification_string}.sorted.filtered.bam", ref_genome = "analysis_default", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"], sample = samples),
        sortedbai = expand("ldna/intermediates/{sample}/alignments/{rate}/{ref_genome}/{sample}.{type}.{modification_string}.sorted.filtered.bam.bai", ref_genome = "analysis_default",rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"], sample = samples),
        dmrs = "ldna/results/{mod_code}/tables/dmrs.tsv",
        repeatmaskerbgz = "/users/mkelsey/data/Nanopore/alz/RTE/aref/extended/A.REF_annotations/A.REF_repeatmasker.complete.gtf.gz",
    resources:
        runtime = 180,
        mem_mb = 5000
    params:
        ref = config["ldna"]["reference"],
        refseqbgz = config["ldna"]["refseqbgz"],
        methylartist_bam_config = config["ldna"]["methylartist_bam_config"],
        methylartist_loci_of_interest = config["ldna"]["methylartist_loci_of_interest"],
        module_prefix = config["ldna"]["prefix"],
        outputprefix = lambda wildcards: "results/%s/plots/methylartist/locus/loci_of_interest_"%wildcards.mod_code,
    output:
        "ldna/results/{mod_code}/plots/methylartist/locus/methylartistregionplot_loci_of_interest.outfile"
    conda:
        "methylartist2"
    shell:
        r"""
mkdir -p $(dirname {output})
outputprefix=$(dirname {output})/methylartistlocusplot_loci_of_interest_
bams=$(echo {input.sortedbam})
commabams=$(echo $bams | tr ' ' ',')
coords=$(awk '{{print $1":"$2"-"$3}}' {params.methylartist_loci_of_interest})
mapfile -t coords_array <<< "$coords"
for coord in "${{coords_array[@]}}"
do
coordfnsafe=$(echo $coord | sed 's/:/-/')
echo $coordfnsafe
if /users/mkelsey/data/tools/methylartist/methylartist region \
--bams {params.methylartist_bam_config} \
-i $coord \
-m m \
--genes {input.repeatmaskerbgz} \
 -p 32 --ref {params.ref} --samplepalette magma --motif CG \
 -l 101126888-101129371 --highlightpalette viridis \
 --highlight_bed {input.dmrs} \
--skip_align_plot
then
echo "worked"
else
echo "failed"
fi
if /users/mkelsey/data/tools/methylartist/methylartist locus --bams {params.methylartist_bam_config} -o ${{outputprefix}}${{coordfnsafe}}.png -i $coord --ref {params.ref} --motif CG -m m --highlight_bed {input.dmrs} -p 1,6,1,0,4 --labelgenes --svg; then
echo "worked"
else
echo "failed"
fi
done
touch {output}       
        """



# -g {params.refseqbgz}

# rule methylartistlocusplot5UTR:
#     input:
#         sortedbam = expand("intermediates/{sample}/alignments/{sample}.filtered.bam", sample = samples),
#         bai = expand("intermediates/{sample}/alignments/{sample}.filtered.bam.bai", sample = samples)
#     resources:
#         runtime = 180,
#         mem_mb = 5000
#     params:
#         ref = config["ldna"]["hs1sorted"],
#         genes = config["ldna"]["genes"],
#         l1hsintact = config["ldna"]["l1hsintact"],
#         outputprefix = "results/plots/methylartist/locus/l1hsintact_"

#     output:
#         "results/plots/methylartist/locus/methylartistlocusplot5UTR.outfile"
#     conda:
#         "methylartist"
#     shell:
#         r"""
# mkdir -p $(dirname {output})
# outputprefix=$(dirname {output})/methylartistlocusplot5UTR
# bams=$(echo {input.sortedbam}) 2> {log}
# commabams=$(echo $bams | tr ' ' ',') 2>> {log}
# coords=$(awk '{{ if ($6 == "+") {{print $1":"$2"-"$2+909}} else {{print $1":"$3-909"-"$3}} }}' {params.l1hsintact})
# mapfile -t coords_array <<< "$coords"
# for coord in "${{coords_array[@]}}"
# do
# coordfnsafe=$(echo $coord | sed 's/:/-/')
# if /users/mkelsey/data/tools/methylartist/methylartist locus --bams {params.bamconfig["ldna"]} -o ${{outputprefix}}${{coordfnsafe}}.png -i $coord --ref {params.ref} --motif CG -m m --highlight_bed {config["ldna"][prefix]}/results/tables/dmrs.bed -g /users/mkelsey/data/ref/genomes/hs1/annotations3/RTE/l1hsintact.gff.gz  -p 1,6,1,3,4 --labelgenes >> {log} 2>> {log}; then
# echo "worked"
# else
# echo "failed"
# fi
# if /users/mkelsey/data/tools/methylartist/methylartist locus --bams {params.bamconfig["ldna"]} -o ${{outputprefix}}${{coordfnsafe}}.png -i $coord --ref {params.ref} --motif CG -m m --highlight_bed {config["ldna"][prefix]}/results/tables/dmrs.bed -g /users/mkelsey/data/ref/genomes/hs1/annotations3/RTE/l1hsintact.gff.gz  -p 1,6,1,3,4 --labelgenes --svg >> {log} 2>> {log}; then
# echo "worked"
# else
# echo "failed"
# fi
# done
# touch {output}       
#         """

# rule methylartistlocusplotexpandedview:
#     input:
#         sortedbam = expand("intermediates/{sample}/alignments/{sample}.filtered.bam", sample = samples),
#         bai = expand("intermediates/{sample}/alignments/{sample}.filtered.bam.bai", sample = samples)
#     resources:
#         runtime = 180,
#         mem_mb = 5000
#     params:
#         ref = config["ldna"]["hs1sorted"],
#         bamconfig["ldna"] = "conf/methylartist_bam_config.txt",
#         genes = config["ldna"]["genes"],
#         l1hsintact = config["ldna"]["l1hsintact"],
#         outputprefix = "results/plots/methylartist/locus/l1hsintact_"

#     output:
#         "outfiles/methylartistlocusplotexpandedview.txt"
#     log:
#         "logs/methylartistlocusplotexpandedview.log"
#     conda:
#         "methylartist"
#     shell:
#         r"""
# bams=$(echo {input.sortedbam}) 2> {log}
# commabams=$(echo $bams | tr ' ' ',') 2>> {log}
# coords=$(awk '{{print $1":"$2-6000"-"$3+6000}}' {params.l1hsintact})
# mapfile -t coords_array <<< "$coords"
# for coord in "${{coords_array[@]}}"
# do
# coordfnsafe=$(echo $coord | sed 's/:/-/')
# if /users/mkelsey/data/tools/methylartist/methylartist locus --bams {params.bamconfig["ldna"]} -o {params.outputprefix}${{coordfnsafe}}.png -i $coord --ref {params.ref} --motif CG -m m --highlight_bed results/tables/dmrs.bed -g /users/mkelsey/data/ref/genomes/hs1/annotations3/RTE/l1hsintact.gff.gz  -p 1,6,1,3,4 --labelgenes >> {log} 2>> {log}; then
# echo "worked"
# else
# echo "failed"
# fi
# if /users/mkelsey/data/tools/methylartist/methylartist locus --bams {params.bamconfig["ldna"]} -o {params.outputprefix}${{coordfnsafe}}.png -i $coord --ref {params.ref} --motif CG -m m --highlight_bed results/tables/dmrs.bed -g /users/mkelsey/data/ref/genomes/hs1/annotations3/RTE/l1hsintact.gff.gz  -p 1,6,1,3,4 --labelgenes --svg >> {log} 2>> {log}; then
# echo "worked"
# else
# echo "failed"
# fi
# done
# touch {output}       
#         """

# rule methylartistlocusplotexpandedviewltr5:
#     input:
#         sortedbam = expand("intermediates/{sample}/alignments/{sample}.filtered.bam", sample = samples),
#         bai = expand("intermediates/{sample}/alignments/{sample}.filtered.bam.bai", sample = samples)
#     resources:
#         runtime = 180,
#         mem_mb = 5000
#     params:
#         ref = config["ldna"]["hs1sorted"],
#         genes = config["ldna"]["genes"],
#         l1hsintact = config["ldna"]["l1hsintact"],
#         bamconfig["ldna"] = "conf/methylartist_bam_config.txt",
#         outputprefix = "results/plots/methylartist/locus/testlocus_l1hsintact_"

#     output:
#         "outfiles/methylartistlocusplotexpandedviewltr.txt"
#     log:
#         "logs/methylartistlocusplotexpandedview.log"
#     conda:
#         "methylartist"
#     shell:
#         r"""
# bams=$(echo {input.sortedbam}) 2> {log}
# commabams=$(echo $bams | tr ' ' ',') 2>> {log}
# coords=$(awk '{{print $1":"$2-6000"-"$3+6000}}' /oscar/data/jsedivy/mkelsey/ref/genomes/hs1/annotations3/RTE/ltr5intact.bed)
# mapfile -t coords_array <<< "$coords"
# for coord in "${{coords_array[@]}}"
# do
# coordfnsafe=$(echo $coord | sed 's/:/-/')
# if /users/mkelsey/data/tools/methylartist/methylartist locus --bams {params.bamconfig["ldna"]} -o {params.outputprefix}${{coordfnsafe}}.png -i $coord --ref {params.ref} --motif CG -m m --highlight_bed results/tables/dmrs.methylartistHighlight.txt -g /oscar/data/jsedivy/mkelsey/ref/genomes/hs1/annotations3/RTE/ltr5intact.gff.gz  -p 1,6,1,3,4 --labelgenes >> {log} 2>> {log}; then
# echo "worked"
# else
# echo "failed"
# fi
# done
# touch {output}       
#         """

# #awk script to get gff in proper format for bgzip, tabix, and methylartist (note the space at the end and the feature being transcript)
# # awk -v OFS="\t" '{print $1,"hub_3671779_hs1_hub_3671779_ncbiRefSeqCurated","transcript", $2, $3, "0.000000", $6, ".", "gene_id \"l1hsintact\"; transcript_id \"l1hsintact\"; "}' l1hsintact.bed > good.gff
# # /users/mkelsey/data/tools/methylartist/methylartist locus --bams {params.bamconfig["ldna"]} -o results/plots/methylartist/locus/testlocus_l1hsintact_chr1-71385136-71403481.png -i chr1:71384136-71404481 --ref /users/mkelsey/data/ref/genomes/hs1/hs1.sorted.fa --motif CG -m m --highlight_bed results/tables/dmrs.methylartistHighlight.txt -g /users/mkelsey/data/ref/genomes/hs1/annotations3/RTE/good.gff.gz -p 1,6,1,3,4
# #awk -v OFS="\t" '{print $1,"hub_3671779_hs1_hub_3671779_ncbiRefSeqCurated","transcript", $2, $3, "0.000000", $6, ".", "gene_id \""$4"\"; transcript_id \""$4"\"; "}' ltr5intact.bed > ltr5intact.gff
# rule methylartistcomposite:
#     input:
#         sortedbams = expand("intermediates/{sample}/alignments/{sample}.filtered.bam", sample = samples),
#         bai = expand("intermediates/{sample}/alignments/{sample}.filtered.bam.bai", sample = samples)
#     params:
#         ref = config["ldna"]["hs1sorted"],
#         genes = config["ldna"]["genes"],
#         intactl1hss = config["ldna"]["l1hsintact"],
#         l13 = config["ldna"]["l13"],
#         l13orfs = config["ldna"]["l13orfs"],
#         repeats = config["ldna"]["repeatsbgzip"],
#         bamconfig["ldna"] = "conf/methylartist_bam_config.txt"
#     resources:
#         runtime = 30,
#         mem_mb = 100000,
#         cpus_per_task = 30
#     output:
#        "results/plots/methylartist/composite_intactl1hs.png" 
#     log:
#         "logs/methylartistcomposited.log"
#     conda:
#         "methylartist"
#     shell:
#         r"""
# cut -f1,2,3,6 {params.intactl1hss} > tempIntactL1hs.bed
# /users/mkelsey/data/tools/methylartist/methylartist composite --bams {params.bamconfig["ldna"]} --meanplot_cutoff 5 -s tempIntactL1hs.bed -r {params.ref} -o {output} -t {params.l13} --mod m --primary_only -p {resources.cpus_per_task} --blocks {params.l13orfs}
#         """

# rule callMethylartistPlots:
#     input:
#         composite = "results/plots/methylartist/composite_intactl1hs.png",
#         locus5utr = "outfiles/methylartistlocusplot5UTR.txt",
#         locus = "outfiles/methylartistlocusplot.txt",
#         locusextended = "outfiles/methylartistlocusplotexpandedview.txt"

#tag MOTIF_ANALYSIS
rule gimme:
    input:
        promoters_bed = "ldna/Rintermediates/{mod_code}/promoters.bed",
        dmrpromoterhyper_bed = "ldna/Rintermediates/{mod_code}/promoters_dmhyperregions.bed",
        dmrpromoterhypo_bed = "ldna/Rintermediates/{mod_code}/promoters_dmhyporegions.bed"
    params:
        ref = config["ldna"]["reference"],
        pwms = config["ldna"]["tf_position_weighted_matrices"]
    output:
        hypo = "ldna/results/{mod_code}/gimme/hypo/gimme.roc.report.txt",
        hyper = "ldna/results/{mod_code}/gimme/hyper/gimme.roc.report.txt"
    resources:
        cpus_per_task = 26,
        mem_mb = 64000,
        runtime = 300
    conda:
        "gimme"
    shell:
        """
bedtools getfasta -fi {params.ref} -bed {input.promoters_bed} -fo ${{{input.promoters_bed}%.*}}.fa
bedtools getfasta -fi {params.ref} -bed {input.dmrpromoterhyper_bed} -fo ${{{input.dmrpromoterhyper_bed}%.*}}.fa
bedtools getfasta -fi {params.ref} -bed {input.dmrpromoterhypo_bed} -fo ${{{input.dmrpromoterhypo_bed}%.*}}.fa
gimme motifs ${{{input.dmrpromoterhyper_bed}%.*}}.fa $(dirname {output.hyper}) --background gc -g {params.ref} --known --nthreads 24 -p {params.pwms} --size 500 --noreport
gimme motifs ${{{input.dmrpromoterhypo_bed}%.*}}.fa $(dirname {output.hypo}) --background gc -g {params.ref} --known --nthreads 24 -p {params.pwms} --size 500 --noreport
        """


rule gimme_maelstrom:
    input:
        clusters = "/users/mkelsey/data/n2102ep/RTE/ldna/Rintermediates/{mod_code}/l1_dif_meth_for_motif_analysis.tsv"
    params:
        ref = config["ldna"]["reference"],
    output:
        out = "ldna/results/{mod_code}/gimme/l1hs_promoter_methylation_dif_motif.out75.outfile"
    container: "https://depot.galaxyproject.org/singularity/gimmemotifs:0.17.1--py39h67e14b5_1"
    resources:
        cpus_per_task = 26,
        mem_mb = 64000,
        runtime = 300
    shell:
        """
gimme maelstrom  --nthreads 24  {input.clusters} {params.ref} $(dirname {output.out})
touch {output.out}
        """

rule gimmeplots:
    input:
        hypo = "ldna/results/{mod_code}/gimme/hypo/gimme.roc.report.txt",
        hyper = "ldna/results/{mod_code}/gimme/hyper/gimme.roc.report.txt"
    output:
        plots = "ldna/results/{mod_code}/gimme/gimme_plots.rds",
    conda:
        "ds"
    script:
        "scripts/gimmeplots.R"
        
# rule homer_find_motifs:
#     input:
#         dmrs = "results/tables/dmrs.tsv"
#     params:
#         hs1 = config["ldna"]["hs1sorted"],
#         outputdir = "results/homer"
#     output:
#         "homeroutfile.txt"
#     conda:
#         "omics"
#     log:
#         "logs/homer_find_motifs.log"
#     shell:
#         r"""
# awk '{{IFS=OFS="\t"}}; {{print "DMR" NR, $1, $2, $3, "+"}}' {input.dmrs} > tempbed.bed
# findMotifsGenome.pl tempbed.bed {params.hs1} {params.outputdir} -size given
# touch {output}
#         """

#tag INSERT_ANALYSIS
rule extractFastqs:
    input:
        bam = "ldna/intermediates/{sample}/alignments/{sample}.sorted.bam"
    output:
        fastq = "ldna/intermediates/{sample}/fastqs/{sample}.fq"
    resources:
        cpus_per_task =10,
        threads = 10,
        runtime = 300,
        mem_mb = 32000
    conda: "omics"
    shell:
        """
mkdir -p $(dirname {output})
samtools fastq -c6 -@8 {input.bam} > {output.fastq}
        """

rule reAlignFqs:
    input:
        fastq = "ldna/intermediates/{sample}/fastqs/{sample}.fq"
    output:
        targetAlignment = "ldna/intermediates/{sample}/alignments/{sample}_to_{target, [A-Za-z0-9]+}.bam",
        targetAlignmentindex = "ldna/intermediates/{sample}/alignments/{sample}_to_{target, [A-Za-z0-9]+}.bam.bai",
    params:
        refGenome = config["ldna"]["reference"],
        targetFasta = lambda wildcards: config["ldna"]["{}Fasta".format(wildcards.target)]
    conda: "omics"
    resources:
        cpus_per_task =32,
        threads = 32,
        runtime = 1200,
        mem_mb = 128000,
    shell:
        """
mkdir -p $(dirname {output})

cat {params.refGenome} {params.targetFasta} > temp_{wildcards.sample}_{wildcards.target}.fa
minimap2 -ax map-ont -t 20 temp_{wildcards.sample}_{wildcards.target}.fa {input.fastq} \
| samtools sort -@4 -T $(dirname {output.targetAlignment}) -O bam -o {output.targetAlignment}
samtools index -@8 {output.targetAlignment}
        """

rule reAlignFqsExtractRegion:
    input:
        targetAlignment = "ldna/intermediates/{sample}/alignments/{sample}_to_{target}.bam",
    output:
        targetAlignmentROI = "ldna/intermediates/{sample}/alignments/{sample}_to_{target}_ROI.bam",
    params:
        refGenome = config["ldna"]["reference"],
        targetFasta = lambda wildcards: config["ldna"]["{}Fasta".format(wildcards.target)]
    conda: "omics"
    resources:
        cpus_per_task =32,
        threads = 32,
        runtime = 600,
        mem_mb = 128000,
    shell:
        """
mkdir -p $(dirname {output})

samtools view -h -b {input.targetAlignment} "$(basename {params.targetFasta})" > {output.targetAlignmentROI}
samtools index {output.targetAlignmentROI}
        """


rule extractReadIDs:
    input:
        targetAlignmentROI = "ldna/intermediates/{sample}/alignments/{sample}_to_{target}_ROI.bam"
    output:
        readIDs = "ldna/intermediates/{sample}/alignments/{sample}_to_{target}_ROI.readIDs.txt"
    conda: "omics"
    resources:
        cpus_per_task =10,
        threads = 10,
        runtime = 600,
        mem_mb = 64000,
    shell:
        """
mkdir -p $(dirname {output})
samtools view {input.targetAlignmentROI} | awk -F'\t' '{{print $1}}' > {output.readIDs}
        """


rule subsetBamByReadIDs:
    input:
        genomebam = "ldna/intermediates/{sample}/alignments/{sample}.sorted.filtered.bam",
        readIDs = "ldna/intermediates/{sample}/alignments/{sample}_to_{target}_ROI.readIDs.txt"
    output:
        bam = "ldna/intermediates/{sample}/alignments/{sample}_genome_extracted_reads_that_mapped_to_{target}.bam",
    conda: "omics"
    resources:
        cpus_per_task =10,
        threads = 10,
        runtime = 600,
        mem_mb = 64000,
    shell:
        """
mkdir -p $(dirname {output})

samtools view -b -F 2304 -N {input.readIDs} {input.genomebam} > {output.bam}
        """

#tag ASSEMBLY
rule subsetFqByReadIDsForAssembly:
    input:
        fq = "ldna/intermediates/{sample}/fastqs/{sample}.fq",
        readIDs = "ldna/intermediates/{sample}/alignments/{sample}_to_{target}_ROI.readIDs.txt"
    output:
        fq = "ldna/results/assembly/{sample}/forAssembly_{sample}_to_{target}forAssembly_.fq",
    conda: "omics"
    resources:
        cpus_per_task =10,
        threads = 10,
        runtime = 100,
        mem_mb = 32000,
    shell:
        """
mkdir -p $(dirname {output})

awk '!seen[$0]++' {input.readIDs} > {input.readIDs}.duplicatefiltered
seqtk subseq {input.fq} {input.readIDs}.duplicatefiltered  > {output.fq}
rm {input.readIDs}.duplicatefiltered
        """

rule flyeAll:
    input:
        fq = "ldna/intermediates/{sample}/fastqs/{sample}.fq"
    output:
        outfile =  "ldna/assembly/{sample}/{sample}.out",
    resources:
        cpus_per_task =32,
        mem_mb = 200000,
        runtime = 2400
    conda:
        "omics"
    shell:
        """
mkdir -p $(dirname {output})
flye --nano-raw {input.fq} --out-dir $(dirname {output.outfile}) --threads 30
touch {output.outfile}
        """


rule makeblastdb:
    input:
        fa = "ldna/assembly/{sample}/assembly.fasta",
    output:
        outfile = "ldna/assembly/{sample}/blastdb.outfile"
    conda:
        "omics"
    resources:
        cpus_per_task = 10,
        mem_mb = 32000,
        runtime = 100
    shell:
        """
mkdir -p $(dirname {output})

makeblastdb -in {input.fa} -dbtype 'nucl' -out $(dirname {output})/blastdb
touch {output.outfile}
        """

rule blastn:
    input:
        outfile = "ldna/assembly/{sample}/blastdb.outfile"
    params:
        targetFasta = lambda wildcards: config["ldna"]["{}Fasta".format(wildcards.target)]
    output:
        blastn = "ldna/assembly/{sample}/{target}.blastn.out"
    conda:
        "omics"
    resources:
        cpus_per_task = 10,
        mem_mb = 32000,
        runtime = 100
    shell:
        """
mkdir -p $(dirname {output})

blastn -db assembly/{wildcards.sample}/blastdb -query {params.targetFasta} -out {output.blastn} -outfmt 0
        """

rule flye:
    input:
        fq = "ldna/results/assembly/{sample}/forAssembly_{sample}_to_{target}forAssembly_.fq"
    output:
        outfile =  "ldna/results/assembly/{sample}/{target}/{target}.out",
    resources:
        cpus_per_task =32,
        mem_mb = 128000
    conda:
        "omics"
    shell:
        """
mkdir -p $(dirname {output})

mkdir -p $(dirname {output.outfile})
flye --nano-raw {input.fq} --out-dir $(dirname {output.outfile}) --threads 30
        """


# #tag VARIANT_CALLING
# rule clair3:
#     input:
#         sortedbam = expand("ldna/intermediates/{{sample}}/alignments/{rate}/{ref_genome}/{{sample}}.{type}.{modification_string}.sorted.filtered.bam", ref_genome = "analysis_default", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"]),
#         sortedbamindex = expand("ldna/intermediates/{{sample}}/alignments/{rate}/{ref_genome}/{{sample}}.{type}.{modification_string}.sorted.filtered.bam.bai", ref_genome = "analysis_default", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"])
#     output:
#         vcf = "ldna/intermediates/{sample}/clair3/full_alignment.vcf.gz"
#     params:
#         ref = config["ldna"]["reference"],
#         clair3model = config["ldna"]["clair3model"]
#     threads: 32
#     resources:
#         runtime = 1000,
#         mem_mb = 128000,
#     conda: "clair3"
#     shell:
#         """
# wd=$(pwd)
# mkdir -p $(dirname {output})
# run_clair3.sh \
# --indel_min_af=0.05 \
# --bam_fn="{input.sortedbam}" \
# --ref_fn="{params.ref}" \
# --threads=24 \
# --platform="ont" \
# --model_path={params.clair3model} --output=${{wd}}/$(dirname {output.vcf})
#         """

# rule clair3ROI:
#     input:
#         sortedbam = expand("ldna/intermediates/{{sample}}/alignments/{rate}/{ref_genome}/{{sample}}.{type}.{modification_string}.sorted.filtered.bam", ref_genome = "analysis_default", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"]),
#         sortedbamindex = expand("ldna/intermediates/{{sample}}/alignments/{rate}/{ref_genome}/{{sample}}.{type}.{modification_string}.sorted.filtered.bam.bai", ref_genome = "analysis_default", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"])
#     output:
#         outfile = "ldna/intermediates/{sample}/clair3ROIAF{sample}.outfile"
#     params:
#         ref = config["ldna"]["reference"],
#         roi = "/oscar/data/jsedivy/mkelsey/ref/genomes/hs1/annotations4/hs1.repeatMasker.l1hs.bed",
#         clair3model = config["ldna"]["clair3model"]
#     threads: 32
#     resources:
#         runtime = 1000,
#         mem_mb = 128000,
#     conda: "clair3"
#     shell:
#         """
# wd=$(pwd)
# mkdir -p $(dirname {output})
# run_clair3.sh \
# --indel_min_af=0.05 \
# --bed_fn="{params.roi}" \
# --bam_fn="{input.sortedbam}" \
# --ref_fn="{params.ref}" \
# --threads=24 \
# --platform="ont" \
# --model_path={params.clair3model} --output=${{wd}}/$(dirname {output})

# touch {output.outfile}
#         """
rule bedmethyl_to_illumina450k_probe_id:
    input:
        bedmethylpaths = expand("ldna/intermediates/{sample}/methylation/hg38/{sample}_CG_bedMethyl.bed", sample = samples)
    conda: 
        "ds"
    output:
        csv = "ldna/intermediates/agg/cpg_formatted_methylation_filtered.csv"
    resources:
        runtime = 100,
        mem_mb = 128000,
        cpus_per_task = 4
    script:
        "scripts/bedmeth_to_illumina450k.R"

rule pyaging_clock:
    input:
        csv = "ldna/intermediates/agg/cpg_formatted_methylation_filtered.csv"
    conda: 
        "pyaging"
    output:
        csv = "ldna/results/m/tables/clocks/pyaging_clock_results.csv"
    resources:
        runtime = 100,
        mem_mb = 50000,
        cpus_per_task = 4
    script:
        "scripts/pyaging_clock.py"

rule R_clock:
    input:
        csv = "ldna/intermediates/agg/cpg_formatted_methylation_filtered.csv"
    conda: 
        "repeatanalysis"
    output:
        csv = "ldna/results/m/tables/clocks/R_clock_results.csv"
    resources:
        runtime = 100,
        mem_mb = 50000,
        cpus_per_task = 4
    script:
        "scripts/R_clock.R"

rule pyaging_clock_analysis:
    input:
        csv = "ldna/results/m/tables/clocks/pyaging_clock_results.csv"
    conda: 
        "repeatanalysis"
    output:
        csv = "ldna/results/m/plots/clocks/pyaging_clock_plots.outfile"
    resources:
        runtime = 30,
        mem_mb = 50000,
        cpus_per_task = 4
    script:
        "scripts/pyaging_clock_analysis.R"

rule deconv:
    input:
        deconv = "ldna/results/m/wgbs/hg38/tables/deconv.csv"
    conda: 
        "repeatanalysis"
    output:
        outfile = "ldna/results/m/plots/deconvolve/deconv.outfile"
    resources:
        runtime = 30,
        mem_mb = 50000,
        cpus_per_task = 4
    script:
        "scripts/deconv.R"

